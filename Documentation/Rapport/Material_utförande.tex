\mychapter{Metod \& Genomförande} % (To be reviwed)
Metoden för denna undersökning bygger på en implementering av \acrshort{aes} i programmeringsspråket
\gls{python}. Detta tillsammans med ett antal konstruerade tester även dom implementerade i
\gls{python} är vad som använts för själva undersökningen av \acrshort{aes}. Koden
är skriven med hjälp av programmet \gls{vscode} och är byggd huvudsakligen för \gls{python} 3.10 men
på grund av att \gls{python} 3.11 släpptes innan undersökningen genomfördes så är de istället \gls{python} 3.11.0
som användes under undersöknings genomförandet.\footfullcite{python311}

\section{Implementering} % (To be reviwed)
Implementeringen av \acrshort{aes} är uppdelad i ett antal funktioner till stor del är baserat på
hur strukturen och uppdelningen av \acrshort{aes} beskrivs i \citetitle{daemen1999aes}\footcite{daemen1999aes}.
Några av det Huvudsakliga funktionerna av algoritmen är som följande:
\begin{itemize}
    \item \texttt{\nameref{sec:aes-subbytes}}
    \item \texttt{\nameref{sec:aes-shiftrows}}
    \item \texttt{\nameref{sec:aes-mixcolumns}}
\end{itemize}

Dessa funktioner används i varje runda och utgör grunden av algoritmen. Utöver detta finns
även \nameref{sec:aes-addroundkey} som används för att lägga till nyckeln i varje runda. AddRoundKey steget är dock inte
en funktion eftersom det enbart består ut av en \gls{xor}-operation. Utöver detta finns det även
en funktion som används för att expandera nyckeln som beskrivs i \nameref{sec:aes-key-expansion} samt
individuella funktioner för kryptering och dekryptering till de olika körlägen \nameref{sec:ecb}, \nameref{sec:cbc} och
\nameref{sec:ofb}.

Implementeringen använder sig av \gls{python} biblioteket NumPy för att hantera matriserna av \gls{byte}s och genomföra
matematiska operationer på dessa. Hela implementeringen går att hitta i appendix \ref{app:python} "\nameref{app:python}" samt
förklaras även i avsnittet \nameref{sec:aes}.

\section{Test Uppsättning} % (To be reviwed)
Test uppsättningen är uppdelad i det tre delarna \nameref{sec:nyckellangd-test}, \nameref{sec:körlages-test} och \nameref{sec:krypterings-test}. Två av delarna, \nameref{sec:nyckellangd-test} och
\nameref{sec:körlages-test} är skrivna som ett \gls{python} script vilket visas i appendix \ref{app:analyze}. När det gäller Krypteringstest så skiljer sig det från de två andra analyserna eftersom det
inte är en automatiserad process utan ett antal praktiska steg som genomfördes för att generera resultatet.

\subsection{Testmiljö} % Describe the test enviroment (might reqiuer extra glossary entrys for some of the terms)
Genomförandet av undersökningen skedde på en Windows dator med \gls{python} 3.11.0 installerat. I syfte att minimerar variabiliteten
mellan de olika omgångarna av tester då allt repeteras ett vist antal gånger så begränsades vissa delar av datorn och anpassningar gjordes i genomförandet.
De begränsningar som placerades på datorn bestod ut av att datorn CPU klockhastighet begränsades till sin grund hastighet för att ge
varje test ett likvärdigt utgångsläge som möjligt. Utöver detta så genomfördes även varje test separat utan parallellisering för att
eliminera risken av att testerna skulle kunna påverka varandra.

\subsection{Nyckellängds Test} % Explain the key length test
\label{sec:nyckellangd-test}
Nyckellängds testet bygger på att varje nyckellängd används för att kryptera en text fil på 1 MB. Detta genomförs 25 gånger för
varje nyckellängd och resultatet av varje test sparas sedan ...

\subsection{Körläges Test} % Explain the mode of operation test
\label{sec:körlages-test}


\subsection{Krypterings Test} % explain how the encryption test is setup
\label{sec:krypterings-test}
Krypterigns testet består utav att man krypterar en bild i bild formatet \gls{ppm} med hjälp av \acrshort{aes} i tre olika körlägen.
PPM formatet används då de tack vare sin enkla struktur kan genomgå en kryptering och fortfarande representeras som en bild
efteråt. Detta gör det då möjligt att visualisera resultatet av krypteringen. För att kryptera bilden används den implementerade
\acrshort{aes} algorithmen som körs i körlägena \nameref{sec:ecb}, \nameref{sec:cbc} och \nameref{sec:ofb} körlägen.

Före och efter krypteringen modifieras dock \gls{ppm} filen så att den går att öppna när den väl är krypterad. Detta görs genom att de fyra
första raderna i filen tas bort och sätts sedan tillbaka efter krypteringen. Detta gör att filen fortfarande kan öppnas som en bild
efter krypteringen.

\section{Genomförande} % Describe how the test was preformed (To be reviwed)
Först kördes Nyckellängdstestet och Körlägestestet genom att köra \gls{python} filen analyze.py. Där efter
genomfördes Krypterings testet. För krypteringstestet valdes först en lämplig bild ut för krypteringen. Sedan
konverterades bilden till fil formatet \gls{ppm} med hjälp av programmet \gls{gimp}. Där efter utförs följande kommandon i en terminal:

\begin{minted}{bash}
    $ head -n 4 pi.ppm > header.txt

    $ tail -n +5 pi.ppm > body.bin

    $ python3 encrypt.py 2b7e151628aed2a6abf7158809cf4f3c body.bin ECB

    $ cat header.txt body.bin.enc > pi-ecb.ppm
\end{minted}

Här används file header.txt som en temporär förvaringsplats för de första fyra raderna i \gls{ppm} filen. Detta
efter som de första fyra raderna innehåller informationen som berättar hur filen senare ska tolkas. Där efter används
tail kommandot för att ta bort de första fyra raderna i filen och skriva resten till en ny fil med namnet body.bin.
Filen body.bin krypteras sedan med hjälp av \gls{python} filen encrypt.py med nyckeln 2b7e151628aed2a6abf7158809cf4f3c.

Innehållet från den nya filen body.bin.enc sätt sedan ihop med innehållet av header.txt som infogas som de fyra första raderna samt filen döps om till pi-ecb.ppm.
Slutligen så konverteras även filen tillbaka till ett mer lätthanterligt format med hjälp av \gls{gimp}.
Processen beskriven ovan upprepades sedan för de två andra körlägen \nameref{sec:cbc} och \nameref{sec:ofb} med
den enda skillnaden att de istället för ECB används CBC och OFB som argument till encrypt.py filen (Det tredje terminal kommandot).

Därefter påbörjades \nameref{sec:nyckellangd-test} och \nameref{sec:körlages-test}, vilket utfördes genom att köra
\gls{python} filen analyze.py. Filen analyze.py genomförde då krypteringen av en textfil på 1MB fylld med slumpmässigt genererade \gls{byte}s med hjälp av \acrshort{aes}
implementeringen som går att se i appendix \ref{app:python}. Detta genomfördes i de tre olika körlägena \acrshort{ecb}, \acrshort{cbc} och \acrshort{ofb} samt de tre olika nyckellängderna 128bit, 192bit och 256bit.
För varje nyckellängd och körläge så genomfördes krypteringen 25 gånger. Resultatet exporterades därefter till 6 olika text filer, vilkas innehåll sedan sammanställdes i \nameref{chap:resultat}.