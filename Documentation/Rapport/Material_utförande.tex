\mychapter{Metod \& Genomförande} % (To be reviwed)
Metoden för denna undersökning bygger på en implementering av \acrshort{aes} i programmeringsspråket
\gls{python}. Detta tillsammans med ett antal konstruerade tester även dom implementerade i
\gls{python} är vad som använts för själva undersökningen av \acrshort{aes}. Koden
är skriven med hjälp av programmet \gls{vscode} och är byggd huvudsakligen för \gls{python} 3.10 men
på grund av att \gls{python} 3.11 släpptes innan undersökningen genomfördes så är de istället \gls{python} 3.11
som användes under undersöknings genomförandet.\footfullcite{python311}

\section{Implementering} % Describe the implementation of the AES algorithm in python (To be reviwed)
Implementeringen av \acrshort{aes} är uppdelad i ett antal funktioner till stor del är baserat på
hur strukturen och uppdelningen av \acrshort{aes} beskrivs i \citetitle{daemen1999aes}\footcite{daemen1999aes}.
Några av det Huvudsakliga funktionerna av algoritmen är som följande:
\begin{itemize}
    \item \texttt{\nameref{sec:aes-subbytes}}
    \item \texttt{\nameref{sec:aes-shiftrows}}
    \item \texttt{\nameref{sec:aes-mixcolumns}}
\end{itemize}

Dessa funktioner används i varje runda och utgör grunden av algoritmen. Utöver detta finns
även \nameref{sec:aes-addroundkey} som används för att lägga till nyckeln i varje runda. AddRoundKey steget är dock inte
en funktion eftersom det enbart består ut av en \gls{xor}-operation. Utöver detta finns det även
en funktion som används för att expandera nyckeln som beskrivs i \nameref{sec:aes-key-expansion} samt
individuella funktioner för kryptering och dekryptering till de olika körlägen \nameref{sec:ecb}, \nameref{sec:cbc} och
\nameref{sec:ofb}.

Implementeringen använder sig av \gls{python} biblioteket NumPy för att hantera matriserna av \gls{byte}s och genomföra
matematiska operationer på dessa. Hela implementeringen går att hitta i appendix \ref{app:python} "\nameref{app:python}".

\section{Test Uppsättning} % Describe the individual test setup for each test and it´s method (describe test enviroment here instead)
Test uppsättningen är uppdelad i tre delar där varje del är konstruerad för att generera ett
resultat i koppling till frågeställningarna för denna undersökning. Två av delarna, \nameref{sec:nyckellängd-test} och
\nameref{sec:körlages-test} är skrivna som ett \gls{python} script som kan köras för att då genererar
resultatet. När det gäller Krypteringstest så skiljer sig det från de två andra testerna eftersom det
inte är ett skript utan ett antal manuella steg som genomfördes för att generera resultatet istället.

\subsection{Nyckellängds Test} % Explain the key length test
\label{sec:nyckellangd-test}


\subsection{Körläges Test} % Explain the mode of operation test
\label{sec:körlages-test}


\subsection{Krypterings Test} % explain how the encryption test is setup
\label{sec:krypterings-test}
Krypterigns testet består utav att man krypterar en bild i bild formatet \gls{ppm} med hjälp av \acrshort{aes} i tre olika körlägen.
PPM formatet används då de tack vare sin enkla struktur kan genomgå en kryptering och fortfarande representeras som en bild
efteråt. Detta gör det då möjligt att visualisera resultatet av krypteringen. För att kryptera bilden används den implementerade
\acrshort{aes} algorithmen som körs i körlägena \nameref{sec:ecb}, \nameref{sec:cbc} och \nameref{sec:ofb} körlägen.

Före och efter krypteringen modifieras dock \gls{ppm} filen så att den går att öppna när den väl är krypterad. Detta görs genom att de fyra
första raderna i filen tas bort och sätts sedan tillbaka efter krypteringen. Detta gör att filen fortfarande kan öppnas som en bild
efter krypteringen.

\section{Genomförande} % Describe how the test was preformed (To be reviwed)
Först kördes Nyckellängdstestet och Körlägestestet genom att köra \gls{python} filen analyze.py. Där efter
genomfördes Krypterings testet. För krypteringstestet valdes först en lämplig bild för krypteringen ut. Sedan
konverterades bilden till \gls{ppm} format med hjälp av programmet \gls{gimp}. Där efter utförs följande kommandon i en terminal:

\begin{minted}{bash}
    $ head -n 4 pi.ppm > header.txt

    $ tail -n +5 pi.ppm > body.bin

    $ python3 encrypt.py 2b7e151628aed2a6abf7158809cf4f3c body.bin ECB

    $ cat header.txt body.bin.enc > pi-ecb.ppm
\end{minted}

Här används file header.txt som en temporär förvaringsplats för de första fyra raderna i \gls{ppm} filen. Detta
efter som de första fyra raderna innehåller informationen som berättar hur filen senare ska tolkas. Där efter används
tail kommandot för att ta bort de första fyra raderna i filen och skriva resten till en ny fil med namnet body.bin.
Därefter krypteras filen body.bin med hjälp av \gls{python} filen encrypt.py med nyckeln 2b7e151628aed2a6abf7158809cf4f3c.

Sedan kopieras innehållet av header.txt tillbaka till filen body.bin.enc och filen body.bin.enc döps om till pi-ecb.ppm.
Slutligen så konverteras även filen tillbaka till ett mer lätthanterligt format med hjälp av \gls{gimp}.
Processen beskriven ovan upprepades sedan för de två andra körlägen \nameref{sec:cbc} och \nameref{sec:ofb} med
den enda skillnaden att de istället för ECB används CBC och OFB som argument till encrypt.py.

Därefter påbörjades \nameref{sec:nyckellangd-test} och \nameref{sec:körlages-test}, vilket utfördes genom att köra
\gls{python} filen analyze.py. Filen analyze.py genomförde då krypteringen av en fil på 1MB med hjälp av \acrshort{aes}
implementeringen i tre olika körlägen och tre olika nyckellängder. Detta genomfördes 25 gånger för varje nyckellängd och
körläge. Resultatet exporterades därefter till 6 olika text filer, vilkas innehåll sedan sammanställts i \nameref{chap:resultat}.