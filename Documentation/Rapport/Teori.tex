\mychapter{Teori}


\section{Kryptering}


\section{Blockchiffer}


\subsection{Körlägen}


\subsubsection{ECB}
\acrfull{ecb} är en av det enklaste blockchiffer körlägena som finns.
\acrshort{ecb} i sig är ganska lätt att förstå och bygger i huvudsak bara på
att man delar upp den data man vill kryptera i delar kallade block och tar sedan varje
block för sig och kör genom algoritmen, vilket tydligt visas i
figur \ref{fig:ecb-mode-enc} \& \ref{fig:ecb-mode-dec}.
\footfullcite{modesofoperation}

Figur \ref{fig:ecb-mode-enc} visar hur \acrshort{ecb} fungerar vid kryptering.
Här visas hur varje block för sig krypteras med hjälp av en blockchiffer algoritm
tillsammans med den givna nyckeln.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{ECB_encryption.png}
    \caption{\acrlong{ecb} kryptering \cite{ecb-mode-enc-ref}}
    \label{fig:ecb-mode-enc}
\end{figure}

Figur \ref{fig:ecb-mode-dec} visar istället hur \acrshort{ecb} fungerar vid
dekryptering, vilken är en till stort sett identisk operation med det enda undantaget
att blockchiffret körs i dekrypterings läge istället för krypterings läge. % May need reformulating!!

\begin{figure}[H]
    \includegraphics[width=\textwidth]{ECB_decryption.png}
    \caption{\acrlong{ecb} dekryptering \cite{ecb-mode-dec-ref}}
    \label{fig:ecb-mode-dec}
\end{figure}

På grund av \acrshort{ecb} körlägets simplicitet så finns det dock även ett ganska
stort problem med detta körläge. Det handlar om att \acrshort{ecb} inte på något
sätt förhindrar att två block med samma innehåll som krypteras inte resulterar i
ett identiskt krypterat block.\footcite{modesofoperation}

Vad detta innebär är att för större mängder data
är att det börjar bildas mönster i skiffertexten. Detta är något som väldigt
tydligt visar sig ifall man krypterar en bild, vilket går att se när man jämför
figur \ref{fig:pi-original} \& \ref{fig:pi-ecb}.
Det här faktumet är även varför \acrshort{ecb} inte är ett säkert körläge
och därför inte används näst intill aldrig i praktiken.\footcite{modesofoperation}

\acrshort{ecb} har däremot även sina fördelar då de bland annat kan parallelliseras
både när de gäller krypteringen och dekrypteringen. Detta samt att \acrshort{ecb}
även gör de möjligt att slumpmässigt dekryptera enskilda block av en skiffertext
utan att man behöver dekryptera hela texten.\footcite{modesofoperation}

\subsubsection{CBC}
\acrlong{cbc} är ett av de mest vanligen använda körlägena för många blockchiffer.
Till skillnad från \acrshort{ecb} så förhindrar \acrshort{cbc} att två block med
samma innehåll kan ge samma krypterade block. Detta gör \acrshort{cbc} genom att
lägga till ett extra steg utöver vad som finns i \acrshort{ecb}. Steget
är en \gls{xor}-operation mellan det krypterade blocket nästkommande block innan
de körs genom blockchiffer algoritmen.\footcite{modesofoperation}
Matematisk sett kan detta formuleras såhär:

\begin{equation}
    \label{eq:cbc-encryption}
    \begin{aligned}
        &S_i = K_n(B_i \oplus S_{i-1})\\\nonumber
        &S_0 = IV
    \end{aligned}
\end{equation}

Där $S_i$ är det krypterade blocket(skiffertexten), $B_i$ är det blocket som ska krypteras,
$K_n$ är blockchiffer algoritmen där $n$ står för nyckeln och $S_{i-1}$ är
det krypterade blocket före det blocket som ska krypteras. \acrshort{iv} är en
\acrfull{iv} som används vid krypteringen av de första blocket då de inte finns
något föregående block att använda. $i$ står för index där de första blocket har
index värdet 1. Hela den här processen kan även ses i figur \ref{fig:cbc-mode-enc}.

\begin{figure}[H]
    \includegraphics[width=\textwidth]{CBC_encryption.png}
    \caption{\acrlong{cbc} kryptering \cite{cbc-mode-enc-ref}}
    \label{fig:cbc-mode-enc}
\end{figure}

När de gäller dekrypterings processen för \acrshort{cbc} så bär den precis som för
\acrshort{ecb} stora likheter med krypterings processen. Det två skillnaderna som
finns är att blockchiffert körs i dekrypterings läge istället för krypterings läge.
Samt att för varje block så genomförs en \gls{xor}-operation mellan det dekrypterade
blocket och föregående block innan dekrypteringen av blocket.\footcite{modesofoperation}
Även detta går att både matematiskt formulera och visuellt visa såhär:

\begin{equation}
    \label{eq:cbc-decryption}
    \begin{aligned}
        &B_i = K_n(S_i) \oplus S_{i-1}\\\nonumber
        &S_0 = IV
    \end{aligned}
\end{equation}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{CBC_decryption.png}
    \caption{\acrlong{cbc} dekryptering \cite{cbc-mode-dec-ref}}
    \label{fig:cbc-mode-dec}
\end{figure}

Fördelarna som kommer från den extra operationen i \acrshort{cbc} till skillnad
från \acrshort{ecb} är då att varje block blir beroende av föregående block.
Detta innebär att dom mönster som kunde dyka upp i \acrshort{ecb} inte längre
kan uppstå, vilket då gör \acrshort{cbc} till ett mer säkert körläge än \acrshort{ecb}.
Dock kräver cbc en ytterligare faktor för att se till så att inte olika medelanden
kan ge samma krypterade block. Därav så krävs en \acrfull{iv} som används vid första
blocket.\footcite{modesofoperation}

\acrshort{cbc} är dock inte prefekt och har i sig också några nackdelar. Där ibland
exempelvis de faktum att en incorrect \acrshort{iv} leder till att de första blocket
inte kan dekrypteras korrekt, detta påverkar dock inte de resterande blocken. På grund
av det så kan man exempelvis lösa problemet genom att första blocket bara innehåller
någon typ av fyllnad, vilket då gör dekrypteringen möjlig utan tillgång till \acrshort{iv}.\footcite{modesofoperation}

Utöver detta så begränsas även \acrshort{cbc} till att bara vara parallelliserbar under
dekrypteringen och inte krypteringen, vilket är en konsekvens av att varje block i \acrshort{cbc}
är beroende av föregående block. \acrshort{cbc} behåller dock fortfarande möjligheten
som \acrshort{ecb} har att slumpmässigt dekryptera enskilda block utan att behöva
dekryptera hela skiffertexten.\footcite{modesofoperation}

\subsubsection{OFB}
\acrlong{ofb} är ett ytterligare körläge som skiljer sig en del från \acrshort{ecb}
och \acrshort{cbc} som  redan presenterats. Den största skillnaden från det andra
körlägena är att \acrshort{ofb} inte använder blockchiffer algoritmen för att kryptera
eller dekryptera blocken. Istället så körs \acrshort{iv} genom blockchiffer algoritmen
och den resulterande \gls{keystream} tillförs sedan genom en \gls{xor}-operation till
blocket som ska krypteras eller dekrypteras.\footcite{modesofoperation}

Tack vare \gls{xor}-operationens symmetriska natur så är så väl krypteringen som
dekrypteringen av \acrshort{ofb} identisk. Detta visas tydligt i figur \ref{fig:ofb-mode-enc}
\& \ref{fig:ofb-mode-dec}:

\begin{figure}[H]
    \includegraphics[width=\textwidth]{OFB_encryption.png}
    \caption{\acrlong{ofb} kryptering \cite{ofb-mode-enc-ref}}
    \label{fig:ofb-mode-enc}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{OFB_decryption.png}
    \caption{\acrlong{ofb} dekryptering \cite{ofb-mode-dec-ref}}
    \label{fig:ofb-mode-dec}
\end{figure}

Utöver detta kan man även matematiskt beskriva \acrshort{ofb}, vilket visas i ekvationen
nedan:

\begin{equation}
    \label{eq:ofb-encryption}
    \begin{aligned}
        &S_i = B_i \oplus O_i\\\nonumber
        &B_i = S_i \oplus O_i\\
        &O_i = K_n(I_i)\\
        &I_i = O_{i-1}\\
        &I_0 = IV
    \end{aligned}
\end{equation}

Här visas \acrshort{ofb} körläget matematiskt där $S_i$ är det krypterade blocket,
$B_i$ är blocket som ska krypteras och $I_0$ är \acrshort{iv}. Men här finns Även
$O_i$ som man kan säga är själva \gls{keystream} som används för att kryptera eller
dekryptera blocket. $O_i$ i sin tur bygger då på att $O_{i-1}$ körs genom blockchiffer
algoritmen igen och sedan används för nästa blocks kryptering.

På grund av att \acrshort{ofb} är utformat på det här sättet och att själva blocken som
ska krypteras inte används fram till sista steget så är det möjligt att genomföra blockskiffer
operationerna i förväg, vilket gör det möjligt att även parallellisera \acrshort{ofb}. Dock
kan \acrshort{ofb} inte parallelliseras ifall man inte gör blockskiffer operationerna
i förväg. Utöver detta saknar även \acrshort{ofb} möjligheten att slumpmässigt dekryptera
enskilda block utan att behöva dekryptera hela skiffertexten.\footcite{modesofoperation}

\section{Symetrisk \& Asymmetrisk Kryptering}
Symetrisk och asymetrisk kryptering handlar om hur nycklar används i olika
krypteringsalgoritmer. För symetriska krypterings algoritmer så betyder detta
att samma nyckel är vad som används för både kryptering och dekryptering. Medans
asymetrisk kryptering bygger på att man använder olika nycklar för kryptering och
dekrypterings processerna.\footfullcite{symencrypt}

De symetriska krypterings algoritmernas huvudsakliga nackdel ligger i de faktum att
de krävs en delad känd nyckel mellan båda parter. Detta är något som Asymetriska
krypterings algorithmer inte behöver, vilket har lett till att man ofta använder
asymetriska krypterings algoritmer för att sköta nyckelutbytet för de symetriska
krypterings algoritmerna. Anledningen till detta är att det symetriska krypterings
algoritmerna ofta är bättre för större data mängder då dom bland annat behöver mycket
kortare nyckellängder.\footcite{symencrypt}

Exempel på symetriska krypterings algoritmer är bland annat \acrshort{aes} och
\acrshort{des} var av \acrshort{aes} kommer förklaras djupare senare i denna rapport.\footcite{symencrypt}
Medans exempel på asymetriska krypterings algoritmer är bland annat \gls{rsa}.\footfullcite{rsa-ref}

\section{AES}


\subsection{Finite Fields}


\subsection{AES S-Box}


\subsection{Struktur}


\subsubsection{SubBytes operation}
SubBytes operationen bygger på ...

\subsubsection{ShiftRows operation}


\subsubsection{MixColumns operation}


\subsubsection{AddRoundKey operation}


\subsection{Nyckel utökning}


\subsubsection{RotWord}


\subsubsection{SubWord}


\subsubsection{Rcon}


\subsection{AES-128bit}


\subsection{AES-192bit}


\subsection{AES-256bit}

